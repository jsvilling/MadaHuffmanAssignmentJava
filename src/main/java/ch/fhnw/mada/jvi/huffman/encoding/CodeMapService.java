package ch.fhnw.mada.jvi.huffman.encoding;

import ch.fhnw.mada.jvi.huffman.tree.HuffmanTreeNode;

import java.util.Map;
import java.util.TreeMap;
import java.util.stream.Stream;

import static ch.fhnw.mada.jvi.huffman.encoding.BitStringUtils.ONE;
import static ch.fhnw.mada.jvi.huffman.encoding.BitStringUtils.ZERO;
import static java.lang.Integer.parseInt;
import static java.util.Arrays.stream;
import static java.util.Comparator.comparingLong;
import static java.util.function.Function.identity;
import static java.util.stream.Collectors.*;

/**
 * Service providing functions to create and convert frequency and encoding maps used for huffman encoding.
 */
public class CodeMapService {

    private static final String CODE_SEPARATOR = ":";
    private static final String SYMBOL_SEPARATOR = "-";
    private static final String EMPTY = "";

    /**
     * Creates the String representation of a huffman encoding. The generated String will have the following format:
     * ASCII code of symbol1:code of symbol1-ASCII code of symbol2:code of symbol 2-...
     *
     * @param codeMap Map<Integer, String> The huffman encoding mapping an encoding to a symbol.
     */
    public String createCodeMapString(Map<Integer, String> codeMap) {
        return codeMap.entrySet().stream().map(this::createCodeString).collect(joining(SYMBOL_SEPARATOR));
    }

    /**
     * Separates the given text by character and creates a Map indication how many times each character appears in the
     * text.
     *
     * @param text String to be converted
     * @return Map<String, Long> - Mapping a single character string to its number of occurences in the text
     */
    public Map<String, Long> createFrequencyMap(String text) {
        return stream(text.split(EMPTY)).collect(groupingBy(identity(), counting()));
    }

    /**
     * Converts a string representation of a huffman code into a Map mapping a single symbol to its encoding. The
     * String representation of the huffman code is expected to have the following format:
     * ASCII code of symbol1:code of symbol1-ASCII code of symbol2:code of symbol 2-...
     *
     * @param codeString - String representation of a huffman code
     * @return
     */
    public Map<String, Character> createCodeMap(String codeString) {
        String[] split = codeString.split(SYMBOL_SEPARATOR);
        return Stream.of(split).map(s -> s.split(CODE_SEPARATOR)).collect(toMap(c -> c[1], c -> (char) parseInt(c[0])));
    }

    /**
     * Converts a frequency map generated by {@link CodeMapService#createFrequencyMap(String)} into a CodeMap. The
     * generated CodeMap maps the Integer representation of the encoding to its respective symbol.
     *
     * @param frequencyMap Map<String, Long> - Mapping a single character string to its number of occurences in a text
     * @return TreeMap<Integer, String> - Mapping the Integer representation the encoded value of a symbol to the respective symbol
     */
    public TreeMap<Integer, String> createCodeMap(Map<String, Long> frequencyMap) {
        HuffmanTreeNode rootNode = buildNodeTree(frequencyMap);
        return buildCodeMap(rootNode, EMPTY);
    }

    /**
     * Creates the String representation with format ASCII code of symbol1:code of symbol1 of a single entry in a CodeMap
     *
     * @param code Map.Entry<Integer, String> map entry containing the code to be converted
     */
    private String createCodeString(Map.Entry<Integer, String> code) {
        return EMPTY + code.getKey() + CODE_SEPARATOR + code.getValue();
    }

    /**
     * Builds a huffman tree which can be used to create the corresponding huffman encoding.
     *
     * The tree is constructed as follows:
     * <ol>
     *     <li>Map each entry of the frequencyMap into a Node using the given character and frequency</li>
     *     <li>Sort all created Nodes by frequency</li>
     *     <li>Create a new Node containing the two nodes with the lowes frequency as subnodes. The frequency of this
     *     node will be the combined frequency of all sub nodes</li>
     *     <li><Remove these two nodes</li>
     *     <li><Repeat 3. and 4. until only one node remains</li>
     * </ol>
     *
     * The remaining node will be the root node of the huffman tree containing all other nodes as subnodes. The code
     * for each character can then be created following down sub nodes until you reach a leaf node.
     * See {@link CodeMapService#buildCodeMap(HuffmanTreeNode, String)}
     *
     * @param frequencyMap - Map mapping a String to its frequency
     * @return The root {@link HuffmanTreeNode} of the corresponding huffman tree
     */
    private HuffmanTreeNode buildNodeTree(Map<String, Long> frequencyMap) {
        return frequencyMap.entrySet().stream()                             // Stream entries of frequency map
                .map(e -> new HuffmanTreeNode(e.getValue(), e.getKey()))    // Create Node from each entry
                .sorted(comparingLong(HuffmanTreeNode::getFrequency))       // Sort by frequency to ensure correct order
                .reduce(HuffmanTreeNode::new).orElseThrow();                // Reduce to parent node
    }

    /**
     * This method builds a CodeMap from the node of a huffman tree. For the initial call this method will be the
     * root node of the huffman tree. For all subsequent recursive calls the node will be a sub node. The created
     * CodeMap maps the Integer representation of the encoded character to its encoded value.
     *
     * The CodeMap is created in the following fashion:
     *
     * <ol>
     *     <li>Check if the given node is a leaf node or has any subnodes</li>
     *     <li>If it has subnodes: Recursively call this method for each subnode</li>
     *     <li>If there is a right sub node the method is recursively called with the subnode and the so far constructed code + 1</li>
     *     <li>If there is a left sub node the method is recursively called with the subnode and the so far constructed code + 0</li>
     *     <li>If the node is a leaf node a CodeMap entry is created from the given constructed code and the character of the leaf node</li>
     * </ol>
     *
     * @param huffmanTreeNode {@link HuffmanTreeNode}
     * @param s The so far created String representation of a given character / node path
     * @return CodeMap mapping the Integer representation of the encoded character to its encoded value
     */
    private TreeMap<Integer, String> buildCodeMap(HuffmanTreeNode huffmanTreeNode, String s) {
        TreeMap<Integer, String> codes = new TreeMap<>();
        if (huffmanTreeNode != null) {
            if (huffmanTreeNode.hasSubnoteRight()) {
                codes.putAll(buildCodeMap(huffmanTreeNode.getSubNodeRight(), s + ONE));
            }
            if (huffmanTreeNode.hasSubnodeLeft()) {
                codes.putAll(buildCodeMap(huffmanTreeNode.getSuNodeLeft(), s + ZERO));
            }
            if (huffmanTreeNode.isLeaf()) {
                codes.put((int) huffmanTreeNode.getCharacter().charAt(0), s);
            }
        }
        return codes;
    }

}
